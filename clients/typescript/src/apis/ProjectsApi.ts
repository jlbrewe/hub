/* tslint:disable */
/* eslint-disable */

/**
 * Stencila Hub Typescript Client
 *
 * This file is auto generated by OpenAPI Generator. Do not edit manually.
 */

import * as runtime from '../runtime';
import {
    InlineResponse20010,
    InlineResponse20010FromJSON,
    InlineResponse20010ToJSON,
    InlineResponse20011,
    InlineResponse20011FromJSON,
    InlineResponse20011ToJSON,
    InlineResponse20012,
    InlineResponse20012FromJSON,
    InlineResponse20012ToJSON,
    InlineResponse20013,
    InlineResponse20013FromJSON,
    InlineResponse20013ToJSON,
    InlineResponse2008,
    InlineResponse2008FromJSON,
    InlineResponse2008ToJSON,
    InlineResponse2009,
    InlineResponse2009FromJSON,
    InlineResponse2009ToJSON,
    Job,
    JobFromJSON,
    JobToJSON,
    ModelFile,
    ModelFileFromJSON,
    ModelFileToJSON,
    Project,
    ProjectFromJSON,
    ProjectToJSON,
    ProjectAgent,
    ProjectAgentFromJSON,
    ProjectAgentToJSON,
    ProjectAgentUpdate,
    ProjectAgentUpdateFromJSON,
    ProjectAgentUpdateToJSON,
    ProjectCreate,
    ProjectCreateFromJSON,
    ProjectCreateToJSON,
    ProjectUpdate,
    ProjectUpdateFromJSON,
    ProjectUpdateToJSON,
    Snapshot,
    SnapshotFromJSON,
    SnapshotToJSON,
} from '../models';

export interface ProjectsAgentsCreateRequest {
    project: string;
}

export interface ProjectsAgentsDeleteRequest {
    agent: string;
    project: string;
}

export interface ProjectsAgentsListRequest {
    project: string;
    limit?: number;
    offset?: number;
}

export interface ProjectsAgentsPartialUpdateRequest {
    agent: string;
    project: string;
    data: ProjectAgentUpdate;
}

export interface ProjectsAgentsReadRequest {
    agent: string;
    project: string;
}

export interface ProjectsConvertRequest {
    file: string;
    project: string;
    data: ModelFile;
}

export interface ProjectsCreateRequest {
    data: ProjectCreate;
}

export interface ProjectsDeleteRequest {
    project: string;
}

export interface ProjectsFilesDeleteRequest {
    file: string;
    project: string;
}

export interface ProjectsFilesListRequest {
    project: string;
    limit?: number;
    offset?: number;
}

export interface ProjectsFilesReadRequest {
    file: string;
    project: string;
}

export interface ProjectsHistoryRequest {
    file: string;
    project: string;
}

export interface ProjectsJobsCancelRequest {
    job: string;
    project: string;
    data: Job;
}

export interface ProjectsJobsConnectCreateRequest {
    job: string;
    path: string;
    project: string;
    data: Job;
}

export interface ProjectsJobsConnectReadRequest {
    job: string;
    path: string;
    project: string;
}

export interface ProjectsJobsCreateRequest {
    project: string;
}

export interface ProjectsJobsExecuteRequest {
    project: string;
}

export interface ProjectsJobsListRequest {
    project: string;
    limit?: number;
    offset?: number;
}

export interface ProjectsJobsPartialUpdateRequest {
    job: string;
    project: string;
    data: Job;
}

export interface ProjectsJobsReadRequest {
    job: string;
    project: string;
}

export interface ProjectsListRequest {
    limit?: number;
    offset?: number;
    account?: number;
    role?: string;
    _public?: boolean;
    search?: string;
    source?: string;
}

export interface ProjectsPartialUpdateRequest {
    project: string;
    data: ProjectUpdate;
}

export interface ProjectsPullRequest {
    project: string;
}

export interface ProjectsReadRequest {
    project: string;
}

export interface ProjectsSnapshotsArchiveRequest {
    project: string;
    snapshot: string;
}

export interface ProjectsSnapshotsCreateRequest {
    project: string;
    data: Snapshot;
}

export interface ProjectsSnapshotsDeleteRequest {
    project: string;
    snapshot: string;
}

export interface ProjectsSnapshotsFilesRequest {
    path: string;
    project: string;
    snapshot: string;
}

export interface ProjectsSnapshotsListRequest {
    project: string;
    limit?: number;
    offset?: number;
}

export interface ProjectsSnapshotsReadRequest {
    project: string;
    snapshot: string;
}

export interface ProjectsSnapshotsSessionRequest {
    project: string;
    snapshot: string;
    data: Snapshot;
}

export interface ProjectsSourcesCreateRequest {
    project: string;
}

export interface ProjectsSourcesDeleteRequest {
    project: string;
    source: string;
}

export interface ProjectsSourcesListRequest {
    project: string;
    limit?: number;
    offset?: number;
    search?: string;
}

export interface ProjectsSourcesOpenRequest {
    path: string;
    project: string;
    source: string;
}

export interface ProjectsSourcesPartialUpdateRequest {
    project: string;
    source: string;
}

export interface ProjectsSourcesPullRequest {
    project: string;
    source: string;
    data: object;
}

export interface ProjectsSourcesReadRequest {
    project: string;
    source: string;
}

/**
 * 
 */
export class ProjectsApi extends runtime.BaseAPI {

    /**
     * Returns data for the new object.
     * Create an object.
     */
    async projectsAgentsCreateRaw(requestParameters: ProjectsAgentsCreateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsAgentsCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/agents/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns data for the new object.
     * Create an object.
     */
    async projectsAgentsCreate(requestParameters: ProjectsAgentsCreateRequest): Promise<void> {
        await this.projectsAgentsCreateRaw(requestParameters);
    }

    /**
     * Returns an empty response.
     * Destroy an object.
     */
    async projectsAgentsDeleteRaw(requestParameters: ProjectsAgentsDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.agent === null || requestParameters.agent === undefined) {
            throw new runtime.RequiredError('agent','Required parameter requestParameters.agent was null or undefined when calling projectsAgentsDelete.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsAgentsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/agents/{agent}/`.replace(`{${"agent"}}`, encodeURIComponent(String(requestParameters.agent))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns an empty response.
     * Destroy an object.
     */
    async projectsAgentsDelete(requestParameters: ProjectsAgentsDeleteRequest): Promise<void> {
        await this.projectsAgentsDeleteRaw(requestParameters);
    }

    /**
     * Returns a list of objects.
     * List objects.
     */
    async projectsAgentsListRaw(requestParameters: ProjectsAgentsListRequest): Promise<runtime.ApiResponse<InlineResponse2009>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsAgentsList.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/agents/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2009FromJSON(jsonValue));
    }

    /**
     * Returns a list of objects.
     * List objects.
     */
    async projectsAgentsList(requestParameters: ProjectsAgentsListRequest): Promise<InlineResponse2009> {
        const response = await this.projectsAgentsListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns data for the updated object.
     * Update an object.
     */
    async projectsAgentsPartialUpdateRaw(requestParameters: ProjectsAgentsPartialUpdateRequest): Promise<runtime.ApiResponse<ProjectAgentUpdate>> {
        if (requestParameters.agent === null || requestParameters.agent === undefined) {
            throw new runtime.RequiredError('agent','Required parameter requestParameters.agent was null or undefined when calling projectsAgentsPartialUpdate.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsAgentsPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsAgentsPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/agents/{agent}/`.replace(`{${"agent"}}`, encodeURIComponent(String(requestParameters.agent))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectAgentUpdateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectAgentUpdateFromJSON(jsonValue));
    }

    /**
     * Returns data for the updated object.
     * Update an object.
     */
    async projectsAgentsPartialUpdate(requestParameters: ProjectsAgentsPartialUpdateRequest): Promise<ProjectAgentUpdate> {
        const response = await this.projectsAgentsPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns data for the object.
     * Retrieve an object.
     */
    async projectsAgentsReadRaw(requestParameters: ProjectsAgentsReadRequest): Promise<runtime.ApiResponse<ProjectAgent>> {
        if (requestParameters.agent === null || requestParameters.agent === undefined) {
            throw new runtime.RequiredError('agent','Required parameter requestParameters.agent was null or undefined when calling projectsAgentsRead.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsAgentsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/agents/{agent}/`.replace(`{${"agent"}}`, encodeURIComponent(String(requestParameters.agent))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectAgentFromJSON(jsonValue));
    }

    /**
     * Returns data for the object.
     * Retrieve an object.
     */
    async projectsAgentsRead(requestParameters: ProjectsAgentsReadRequest): Promise<ProjectAgent> {
        const response = await this.projectsAgentsReadRaw(requestParameters);
        return await response.value();
    }

    /**
     * Confirms that the destination path and other options are correct, creates a job and redirects to it.
     * Convert a file to another format.
     */
    async projectsConvertRaw(requestParameters: ProjectsConvertRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling projectsConvert.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsConvert.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsConvert.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/files/{file}!convert`.replace(`{${"file"}}`, encodeURIComponent(String(requestParameters.file))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModelFileToJSON(requestParameters.data),
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Confirms that the destination path and other options are correct, creates a job and redirects to it.
     * Convert a file to another format.
     */
    async projectsConvert(requestParameters: ProjectsConvertRequest): Promise<any> {
        const response = await this.projectsConvertRaw(requestParameters);
        return await response.value();
    }

    /**
     * Receives details of the project. Returns details of the new project.
     * Create a project.
     */
    async projectsCreateRaw(requestParameters: ProjectsCreateRequest): Promise<runtime.ApiResponse<ProjectCreate>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectCreateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectCreateFromJSON(jsonValue));
    }

    /**
     * Receives details of the project. Returns details of the new project.
     * Create a project.
     */
    async projectsCreate(requestParameters: ProjectsCreateRequest): Promise<ProjectCreate> {
        const response = await this.projectsCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns an empty response on success.
     * Destroy a project.
     */
    async projectsDeleteRaw(requestParameters: ProjectsDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns an empty response on success.
     * Destroy a project.
     */
    async projectsDelete(requestParameters: ProjectsDeleteRequest): Promise<void> {
        await this.projectsDeleteRaw(requestParameters);
    }

    /**
     * Returns an empty response.
     * Destroy an object.
     */
    async projectsFilesDeleteRaw(requestParameters: ProjectsFilesDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling projectsFilesDelete.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsFilesDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/files/{file}`.replace(`{${"file"}}`, encodeURIComponent(String(requestParameters.file))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns an empty response.
     * Destroy an object.
     */
    async projectsFilesDelete(requestParameters: ProjectsFilesDeleteRequest): Promise<void> {
        await this.projectsFilesDeleteRaw(requestParameters);
    }

    /**
     * Returns a list of objects.
     * List objects.
     */
    async projectsFilesListRaw(requestParameters: ProjectsFilesListRequest): Promise<runtime.ApiResponse<InlineResponse20010>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsFilesList.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/files/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20010FromJSON(jsonValue));
    }

    /**
     * Returns a list of objects.
     * List objects.
     */
    async projectsFilesList(requestParameters: ProjectsFilesListRequest): Promise<InlineResponse20010> {
        const response = await this.projectsFilesListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns data for the object.
     * Retrieve an object.
     */
    async projectsFilesReadRaw(requestParameters: ProjectsFilesReadRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling projectsFilesRead.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsFilesRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/files/{file}`.replace(`{${"file"}}`, encodeURIComponent(String(requestParameters.file))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns data for the object.
     * Retrieve an object.
     */
    async projectsFilesRead(requestParameters: ProjectsFilesReadRequest): Promise<any> {
        const response = await this.projectsFilesReadRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a paginated history of the file
     * Get the a file\'s history.
     */
    async projectsHistoryRaw(requestParameters: ProjectsHistoryRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling projectsHistory.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/files/{file}!history`.replace(`{${"file"}}`, encodeURIComponent(String(requestParameters.file))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Returns a paginated history of the file
     * Get the a file\'s history.
     */
    async projectsHistory(requestParameters: ProjectsHistoryRequest): Promise<any> {
        const response = await this.projectsHistoryRaw(requestParameters);
        return await response.value();
    }

    /**
     * If the job is cancellable, it will be cancelled and it\'s status set to `REVOKED`.
     * Cancel a job.
     */
    async projectsJobsCancelRaw(requestParameters: ProjectsJobsCancelRequest): Promise<runtime.ApiResponse<Job>> {
        if (requestParameters.job === null || requestParameters.job === undefined) {
            throw new runtime.RequiredError('job','Required parameter requestParameters.job was null or undefined when calling projectsJobsCancel.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsJobsCancel.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsJobsCancel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/jobs/{job}/cancel/`.replace(`{${"job"}}`, encodeURIComponent(String(requestParameters.job))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: JobToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JobFromJSON(jsonValue));
    }

    /**
     * If the job is cancellable, it will be cancelled and it\'s status set to `REVOKED`.
     * Cancel a job.
     */
    async projectsJobsCancel(requestParameters: ProjectsJobsCancelRequest): Promise<Job> {
        const response = await this.projectsJobsCancelRaw(requestParameters);
        return await response.value();
    }

    /**
     * Redirects to the internal URL so that users can connect to the job and run methods inside of it, Russian doll style.  This request it proxied through the `router`. This view first checks that the user has permission to edit the job.
     * Connect to a job.
     */
    async projectsJobsConnectCreateRaw(requestParameters: ProjectsJobsConnectCreateRequest): Promise<runtime.ApiResponse<Job>> {
        if (requestParameters.job === null || requestParameters.job === undefined) {
            throw new runtime.RequiredError('job','Required parameter requestParameters.job was null or undefined when calling projectsJobsConnectCreate.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling projectsJobsConnectCreate.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsJobsConnectCreate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsJobsConnectCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/jobs/{job}/connect/{path}/`.replace(`{${"job"}}`, encodeURIComponent(String(requestParameters.job))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: JobToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JobFromJSON(jsonValue));
    }

    /**
     * Redirects to the internal URL so that users can connect to the job and run methods inside of it, Russian doll style.  This request it proxied through the `router`. This view first checks that the user has permission to edit the job.
     * Connect to a job.
     */
    async projectsJobsConnectCreate(requestParameters: ProjectsJobsConnectCreateRequest): Promise<Job> {
        const response = await this.projectsJobsConnectCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Redirects to the internal URL so that users can connect to the job and run methods inside of it, Russian doll style.  This request it proxied through the `router`. This view first checks that the user has permission to edit the job.
     * Connect to a job.
     */
    async projectsJobsConnectReadRaw(requestParameters: ProjectsJobsConnectReadRequest): Promise<runtime.ApiResponse<Job>> {
        if (requestParameters.job === null || requestParameters.job === undefined) {
            throw new runtime.RequiredError('job','Required parameter requestParameters.job was null or undefined when calling projectsJobsConnectRead.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling projectsJobsConnectRead.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsJobsConnectRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/jobs/{job}/connect/{path}/`.replace(`{${"job"}}`, encodeURIComponent(String(requestParameters.job))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JobFromJSON(jsonValue));
    }

    /**
     * Redirects to the internal URL so that users can connect to the job and run methods inside of it, Russian doll style.  This request it proxied through the `router`. This view first checks that the user has permission to edit the job.
     * Connect to a job.
     */
    async projectsJobsConnectRead(requestParameters: ProjectsJobsConnectReadRequest): Promise<Job> {
        const response = await this.projectsJobsConnectReadRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns data for the new object.
     * Create an object.
     */
    async projectsJobsCreateRaw(requestParameters: ProjectsJobsCreateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsJobsCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/jobs/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns data for the new object.
     * Create an object.
     */
    async projectsJobsCreate(requestParameters: ProjectsJobsCreateRequest): Promise<void> {
        await this.projectsJobsCreateRaw(requestParameters);
    }

    /**
     * Receives the `node` to execute as the request body. Returns the executed `node`.
     * Create an execute job.
     */
    async projectsJobsExecuteRaw(requestParameters: ProjectsJobsExecuteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsJobsExecute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/jobs/execute/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Receives the `node` to execute as the request body. Returns the executed `node`.
     * Create an execute job.
     */
    async projectsJobsExecute(requestParameters: ProjectsJobsExecuteRequest): Promise<void> {
        await this.projectsJobsExecuteRaw(requestParameters);
    }

    /**
     * Returns a list of objects.
     * List objects.
     */
    async projectsJobsListRaw(requestParameters: ProjectsJobsListRequest): Promise<runtime.ApiResponse<InlineResponse20011>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsJobsList.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/jobs/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20011FromJSON(jsonValue));
    }

    /**
     * Returns a list of objects.
     * List objects.
     */
    async projectsJobsList(requestParameters: ProjectsJobsListRequest): Promise<InlineResponse20011> {
        const response = await this.projectsJobsListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns data for the updated object.
     * Update an object.
     */
    async projectsJobsPartialUpdateRaw(requestParameters: ProjectsJobsPartialUpdateRequest): Promise<runtime.ApiResponse<Job>> {
        if (requestParameters.job === null || requestParameters.job === undefined) {
            throw new runtime.RequiredError('job','Required parameter requestParameters.job was null or undefined when calling projectsJobsPartialUpdate.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsJobsPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsJobsPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/jobs/{job}/`.replace(`{${"job"}}`, encodeURIComponent(String(requestParameters.job))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: JobToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JobFromJSON(jsonValue));
    }

    /**
     * Returns data for the updated object.
     * Update an object.
     */
    async projectsJobsPartialUpdate(requestParameters: ProjectsJobsPartialUpdateRequest): Promise<Job> {
        const response = await this.projectsJobsPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns data for the object.
     * Retrieve an object.
     */
    async projectsJobsReadRaw(requestParameters: ProjectsJobsReadRequest): Promise<runtime.ApiResponse<Job>> {
        if (requestParameters.job === null || requestParameters.job === undefined) {
            throw new runtime.RequiredError('job','Required parameter requestParameters.job was null or undefined when calling projectsJobsRead.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsJobsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/jobs/{job}/`.replace(`{${"job"}}`, encodeURIComponent(String(requestParameters.job))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JobFromJSON(jsonValue));
    }

    /**
     * Returns data for the object.
     * Retrieve an object.
     */
    async projectsJobsRead(requestParameters: ProjectsJobsReadRequest): Promise<Job> {
        const response = await this.projectsJobsReadRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a list of projects that are accessible to the user, including those that are public and those that the user is a member of (i.e. has a project role for).  The returned list can be filtered using query parameters, `account`, `role`, `public`, `search`, `source`. The `role` filter applies to the currently authenticated user, and as such has no effected for unauthenticated requests. Roles can be specified as a comma separated list e.g. `role=author,manager,owner` or using to the `+` operator to indicate the minimum required role e.g. `role=author+` (equivalent to the previous example).  For example, to list all projects for which the authenticated user is a member and which uses a particular Google Doc as a source:      GET /projects?role=member&source=gdoc://1BW6MubIyDirCGW9Wq-tSqCma8pioxBI6VpeLyXn5mZA
     * List projects.
     */
    async projectsListRaw(requestParameters: ProjectsListRequest): Promise<runtime.ApiResponse<InlineResponse2008>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.account !== undefined) {
            queryParameters['account'] = requestParameters.account;
        }

        if (requestParameters.role !== undefined) {
            queryParameters['role'] = requestParameters.role;
        }

        if (requestParameters._public !== undefined) {
            queryParameters['public'] = requestParameters._public;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.source !== undefined) {
            queryParameters['source'] = requestParameters.source;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse2008FromJSON(jsonValue));
    }

    /**
     * Returns a list of projects that are accessible to the user, including those that are public and those that the user is a member of (i.e. has a project role for).  The returned list can be filtered using query parameters, `account`, `role`, `public`, `search`, `source`. The `role` filter applies to the currently authenticated user, and as such has no effected for unauthenticated requests. Roles can be specified as a comma separated list e.g. `role=author,manager,owner` or using to the `+` operator to indicate the minimum required role e.g. `role=author+` (equivalent to the previous example).  For example, to list all projects for which the authenticated user is a member and which uses a particular Google Doc as a source:      GET /projects?role=member&source=gdoc://1BW6MubIyDirCGW9Wq-tSqCma8pioxBI6VpeLyXn5mZA
     * List projects.
     */
    async projectsList(requestParameters: ProjectsListRequest): Promise<InlineResponse2008> {
        const response = await this.projectsListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Receives details of the project. Returns updated details of the project.
     * Update a project.
     */
    async projectsPartialUpdateRaw(requestParameters: ProjectsPartialUpdateRequest): Promise<runtime.ApiResponse<ProjectUpdate>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectUpdateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectUpdateFromJSON(jsonValue));
    }

    /**
     * Receives details of the project. Returns updated details of the project.
     * Update a project.
     */
    async projectsPartialUpdate(requestParameters: ProjectsPartialUpdateRequest): Promise<ProjectUpdate> {
        const response = await this.projectsPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Creates a pull job and redirects to it.
     * Pull the project.
     */
    async projectsPullRaw(requestParameters: ProjectsPullRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsPull.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/pull/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a pull job and redirects to it.
     * Pull the project.
     */
    async projectsPull(requestParameters: ProjectsPullRequest): Promise<void> {
        await this.projectsPullRaw(requestParameters);
    }

    /**
     * Returns details of the project.
     * Retrieve a project.
     */
    async projectsReadRaw(requestParameters: ProjectsReadRequest): Promise<runtime.ApiResponse<Project>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectFromJSON(jsonValue));
    }

    /**
     * Returns details of the project.
     * Retrieve a project.
     */
    async projectsRead(requestParameters: ProjectsReadRequest): Promise<Project> {
        const response = await this.projectsReadRaw(requestParameters);
        return await response.value();
    }

    /**
     * The user should have read access to the project. Returns a redirect to the URL of the archive.
     * Retrieve an archive for a project snapshot.
     */
    async projectsSnapshotsArchiveRaw(requestParameters: ProjectsSnapshotsArchiveRequest): Promise<runtime.ApiResponse<Snapshot>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSnapshotsArchive.');
        }

        if (requestParameters.snapshot === null || requestParameters.snapshot === undefined) {
            throw new runtime.RequiredError('snapshot','Required parameter requestParameters.snapshot was null or undefined when calling projectsSnapshotsArchive.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/snapshots/{snapshot}/archive/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"snapshot"}}`, encodeURIComponent(String(requestParameters.snapshot))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SnapshotFromJSON(jsonValue));
    }

    /**
     * The user should have read access to the project. Returns a redirect to the URL of the archive.
     * Retrieve an archive for a project snapshot.
     */
    async projectsSnapshotsArchive(requestParameters: ProjectsSnapshotsArchiveRequest): Promise<Snapshot> {
        const response = await this.projectsSnapshotsArchiveRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns data for the new object.
     * Create an object.
     */
    async projectsSnapshotsCreateRaw(requestParameters: ProjectsSnapshotsCreateRequest): Promise<runtime.ApiResponse<Snapshot>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSnapshotsCreate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsSnapshotsCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/snapshots/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SnapshotToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SnapshotFromJSON(jsonValue));
    }

    /**
     * Returns data for the new object.
     * Create an object.
     */
    async projectsSnapshotsCreate(requestParameters: ProjectsSnapshotsCreateRequest): Promise<Snapshot> {
        const response = await this.projectsSnapshotsCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns an empty response.
     * Destroy an object.
     */
    async projectsSnapshotsDeleteRaw(requestParameters: ProjectsSnapshotsDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSnapshotsDelete.');
        }

        if (requestParameters.snapshot === null || requestParameters.snapshot === undefined) {
            throw new runtime.RequiredError('snapshot','Required parameter requestParameters.snapshot was null or undefined when calling projectsSnapshotsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/snapshots/{snapshot}/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"snapshot"}}`, encodeURIComponent(String(requestParameters.snapshot))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns an empty response.
     * Destroy an object.
     */
    async projectsSnapshotsDelete(requestParameters: ProjectsSnapshotsDeleteRequest): Promise<void> {
        await this.projectsSnapshotsDeleteRaw(requestParameters);
    }

    /**
     * For `index.html` will add necessary headers and if necessary inject content required to connect to a session. For other files redirects to the URL for the file (which may be in a remote storage bucket for example).  For security reasons, this function will be deprecated in favour of getting content from the account subdomain.
     * Retrieve a file within a snapshot of the project.
     */
    async projectsSnapshotsFilesRaw(requestParameters: ProjectsSnapshotsFilesRequest): Promise<runtime.ApiResponse<Snapshot>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling projectsSnapshotsFiles.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSnapshotsFiles.');
        }

        if (requestParameters.snapshot === null || requestParameters.snapshot === undefined) {
            throw new runtime.RequiredError('snapshot','Required parameter requestParameters.snapshot was null or undefined when calling projectsSnapshotsFiles.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/snapshots/{snapshot}/files/{path}/`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"snapshot"}}`, encodeURIComponent(String(requestParameters.snapshot))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SnapshotFromJSON(jsonValue));
    }

    /**
     * For `index.html` will add necessary headers and if necessary inject content required to connect to a session. For other files redirects to the URL for the file (which may be in a remote storage bucket for example).  For security reasons, this function will be deprecated in favour of getting content from the account subdomain.
     * Retrieve a file within a snapshot of the project.
     */
    async projectsSnapshotsFiles(requestParameters: ProjectsSnapshotsFilesRequest): Promise<Snapshot> {
        const response = await this.projectsSnapshotsFilesRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a list of objects.
     * List objects.
     */
    async projectsSnapshotsListRaw(requestParameters: ProjectsSnapshotsListRequest): Promise<runtime.ApiResponse<InlineResponse20012>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSnapshotsList.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/snapshots/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20012FromJSON(jsonValue));
    }

    /**
     * Returns a list of objects.
     * List objects.
     */
    async projectsSnapshotsList(requestParameters: ProjectsSnapshotsListRequest): Promise<InlineResponse20012> {
        const response = await this.projectsSnapshotsListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns data for the object.
     * Retrieve an object.
     */
    async projectsSnapshotsReadRaw(requestParameters: ProjectsSnapshotsReadRequest): Promise<runtime.ApiResponse<Snapshot>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSnapshotsRead.');
        }

        if (requestParameters.snapshot === null || requestParameters.snapshot === undefined) {
            throw new runtime.RequiredError('snapshot','Required parameter requestParameters.snapshot was null or undefined when calling projectsSnapshotsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/snapshots/{snapshot}/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"snapshot"}}`, encodeURIComponent(String(requestParameters.snapshot))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SnapshotFromJSON(jsonValue));
    }

    /**
     * Returns data for the object.
     * Retrieve an object.
     */
    async projectsSnapshotsRead(requestParameters: ProjectsSnapshotsReadRequest): Promise<Snapshot> {
        const response = await this.projectsSnapshotsReadRaw(requestParameters);
        return await response.value();
    }

    /**
     * If the user has already created or connected to a `session` job for this snapshot, and that job is still running then will return that job. Otherwise, will create a new session.
     * Get a session with the snapshot as the working directory.
     */
    async projectsSnapshotsSessionRaw(requestParameters: ProjectsSnapshotsSessionRequest): Promise<runtime.ApiResponse<Snapshot>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSnapshotsSession.');
        }

        if (requestParameters.snapshot === null || requestParameters.snapshot === undefined) {
            throw new runtime.RequiredError('snapshot','Required parameter requestParameters.snapshot was null or undefined when calling projectsSnapshotsSession.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsSnapshotsSession.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/snapshots/{snapshot}/session/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"snapshot"}}`, encodeURIComponent(String(requestParameters.snapshot))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SnapshotToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SnapshotFromJSON(jsonValue));
    }

    /**
     * If the user has already created or connected to a `session` job for this snapshot, and that job is still running then will return that job. Otherwise, will create a new session.
     * Get a session with the snapshot as the working directory.
     */
    async projectsSnapshotsSession(requestParameters: ProjectsSnapshotsSessionRequest): Promise<Snapshot> {
        const response = await this.projectsSnapshotsSessionRaw(requestParameters);
        return await response.value();
    }

    /**
     * Receives details of the source. This should include the `type` of source, a string matching one of the implemented source classes e.g. `ElifeSource`, `GoogleDocsSource`, `GithubSource` as well as the destination `path`, and other type specific properties. See https://github.com/stencila/hub/blob/master/manager/projects/models/sources.py.  For example, to create a new source for a Google Doc:  ```json {     \"type\": \"GoogleDocsSource\",     \"path\": \"report.gdoc\",     \"docId\": \"1BW6MubIyDirCGW9Wq-tSqCma8pioxBI6VpeLyXn5mZA\" } ```  Returns details of the new source.
     * Create a project source.
     */
    async projectsSourcesCreateRaw(requestParameters: ProjectsSourcesCreateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSourcesCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/sources/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Receives details of the source. This should include the `type` of source, a string matching one of the implemented source classes e.g. `ElifeSource`, `GoogleDocsSource`, `GithubSource` as well as the destination `path`, and other type specific properties. See https://github.com/stencila/hub/blob/master/manager/projects/models/sources.py.  For example, to create a new source for a Google Doc:  ```json {     \"type\": \"GoogleDocsSource\",     \"path\": \"report.gdoc\",     \"docId\": \"1BW6MubIyDirCGW9Wq-tSqCma8pioxBI6VpeLyXn5mZA\" } ```  Returns details of the new source.
     * Create a project source.
     */
    async projectsSourcesCreate(requestParameters: ProjectsSourcesCreateRequest): Promise<void> {
        await this.projectsSourcesCreateRaw(requestParameters);
    }

    /**
     * Removes the source from the project. Returns an empty response on success.
     * Destroy a project source.
     */
    async projectsSourcesDeleteRaw(requestParameters: ProjectsSourcesDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSourcesDelete.');
        }

        if (requestParameters.source === null || requestParameters.source === undefined) {
            throw new runtime.RequiredError('source','Required parameter requestParameters.source was null or undefined when calling projectsSourcesDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/sources/{source}/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters.source))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes the source from the project. Returns an empty response on success.
     * Destroy a project source.
     */
    async projectsSourcesDelete(requestParameters: ProjectsSourcesDeleteRequest): Promise<void> {
        await this.projectsSourcesDeleteRaw(requestParameters);
    }

    /**
     * Returns a list of sources in the project. The returned list can be filtered using the query parameter, `search` which matches against the source\'s `path` string.
     * List a project\'s sources.
     */
    async projectsSourcesListRaw(requestParameters: ProjectsSourcesListRequest): Promise<runtime.ApiResponse<InlineResponse20013>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSourcesList.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/sources/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse20013FromJSON(jsonValue));
    }

    /**
     * Returns a list of sources in the project. The returned list can be filtered using the query parameter, `search` which matches against the source\'s `path` string.
     * List a project\'s sources.
     */
    async projectsSourcesList(requestParameters: ProjectsSourcesListRequest): Promise<InlineResponse20013> {
        const response = await this.projectsSourcesListRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns a redirect response to an external URL.
     * Open a project source, or a file within it.
     */
    async projectsSourcesOpenRaw(requestParameters: ProjectsSourcesOpenRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling projectsSourcesOpen.');
        }

        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSourcesOpen.');
        }

        if (requestParameters.source === null || requestParameters.source === undefined) {
            throw new runtime.RequiredError('source','Required parameter requestParameters.source was null or undefined when calling projectsSourcesOpen.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/sources/{source}/open/{path}/`.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))).replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters.source))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns a redirect response to an external URL.
     * Open a project source, or a file within it.
     */
    async projectsSourcesOpen(requestParameters: ProjectsSourcesOpenRequest): Promise<object> {
        const response = await this.projectsSourcesOpenRaw(requestParameters);
        return await response.value();
    }

    /**
     * Receives details of the source. Returns updated details of the source.
     * Update a project source.
     */
    async projectsSourcesPartialUpdateRaw(requestParameters: ProjectsSourcesPartialUpdateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSourcesPartialUpdate.');
        }

        if (requestParameters.source === null || requestParameters.source === undefined) {
            throw new runtime.RequiredError('source','Required parameter requestParameters.source was null or undefined when calling projectsSourcesPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/sources/{source}/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters.source))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Receives details of the source. Returns updated details of the source.
     * Update a project source.
     */
    async projectsSourcesPartialUpdate(requestParameters: ProjectsSourcesPartialUpdateRequest): Promise<void> {
        await this.projectsSourcesPartialUpdateRaw(requestParameters);
    }

    /**
     * Creates a pull job and redirects to it.
     * Pull a project source.
     */
    async projectsSourcesPullRaw(requestParameters: ProjectsSourcesPullRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSourcesPull.');
        }

        if (requestParameters.source === null || requestParameters.source === undefined) {
            throw new runtime.RequiredError('source','Required parameter requestParameters.source was null or undefined when calling projectsSourcesPull.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling projectsSourcesPull.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/sources/{source}/pull/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters.source))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.data as any,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Creates a pull job and redirects to it.
     * Pull a project source.
     */
    async projectsSourcesPull(requestParameters: ProjectsSourcesPullRequest): Promise<object> {
        const response = await this.projectsSourcesPullRaw(requestParameters);
        return await response.value();
    }

    /**
     * Returns details of the source.
     * Retrieve a project source.
     */
    async projectsSourcesReadRaw(requestParameters: ProjectsSourcesReadRequest): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling projectsSourcesRead.');
        }

        if (requestParameters.source === null || requestParameters.source === undefined) {
            throw new runtime.RequiredError('source','Required parameter requestParameters.source was null or undefined when calling projectsSourcesRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // Token authentication
        }

        const response = await this.request({
            path: `/projects/{project}/sources/{source}/`.replace(`{${"project"}}`, encodeURIComponent(String(requestParameters.project))).replace(`{${"source"}}`, encodeURIComponent(String(requestParameters.source))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns details of the source.
     * Retrieve a project source.
     */
    async projectsSourcesRead(requestParameters: ProjectsSourcesReadRequest): Promise<object> {
        const response = await this.projectsSourcesReadRaw(requestParameters);
        return await response.value();
    }

}
